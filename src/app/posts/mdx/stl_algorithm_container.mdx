---
title: "C++ STL 컨테이너와 알고리즘 — 다시 시작한 기본기의 힘"
date: "2025-10-22"
category: "c++"
tags: ["stl", "algorithm", "container"]
slug: "stl_algorithm_container"
description: "C++ STL 컨테이너 구조와 알고리즘을 다시 학습하며 느낀 점과 변화의 이해"
---

> “처음 배웠던 C++이지만, 다시 마주하니 전혀 다른 언어처럼 느껴졌다.”


## 서두 — 다시, STL을 마주하며

오랜 기간 C++을 사용해왔지만, 이번에 다시 **STL(Standard Template Library)** 을 체계적으로 정리하면서 스스로 놀랄 만큼 **기초를 놓치고 있었다**는 걸 깨달았다.  

C++98~03 시절, STL은 단지 ‘편의 기능’ 정도로 생각했다.  
업무 환경이 자연스럽게 C#으로 옮겨가면서 STL에 대한 갈증이나 필요성을 느끼지 못했지만, 지금 돌아보면 **“그때 깊이 배우지 않았던 것”** 이 개발자로서 나를 한정시켜왔던 것 같다.


## 1. 컨테이너를 다시 이해하다

### std::vector — 단순하지만 가장 강력한 기본기
연속 메모리 구조, 재할당의 비용, `reserve()`의 중요성…  
예전엔 이런 설명을 봐도 ‘알겠지’ 정도였는데, 지금은 **메모리와 반복자의 무효화(invalidation)** 를 몸으로 이해하게 되었다. 
“언제 vector를 쓰고, 언제 deque로 바꿔야 하는가”가 이제는 명확해졌다.

특히 `emplace_back()`과 `push_back()`의 차이를 직접 코드로 실험해보면서 **객체 생성 비용을 체감**할 수 있었다.  
단 한 줄 차이지만, 생성자 호출과 이동 연산자의 발생 여부가 완전히 달랐다. 그 미묘한 차이를 “감각”으로 이해했다는 것이 이번 학습의 큰 수확이었다.


### std::list / std::deque — 메모리 구조가 바뀌면 사고방식도 바뀐다
예전엔 단순히 “list는 중간 삽입이 빠르다”고 외웠다.  
하지만 실제로는 캐시 효율이 떨어져 전체 성능은 vector보다 느릴 수 있다는 점, **“이론보다 실제 성능을 우선 고려해야 한다”** 는 깨달음을 얻었다.  
C++의 컨테이너는 “모두 빠르다”가 아니라 “**상황에 따라 최적의 도구를 고르는 문제**”라는 사실을 확실히 느꼈다.


## 2. 알고리즘을 다시 바라보다

### sort, stable_sort, partial_sort, nth_element…
이번에 가장 흥미로웠던 부분이다. 그동안은 그냥 “정렬하면 된다” 수준에서 머물렀지만, 이제는 **각 정렬 알고리즘의 내부 구조와 시간 복잡도, 안정성**을 비교할 수 있다.

- `sort`: IntroSort 기반, 평균 O(n log n), 불안정 정렬  
- `stable_sort`: MergeSort 기반, 안정 정렬  
- `partial_sort`: 상위 K개만 정렬할 때 효율적  
- `nth_element`: 특정 위치 기준으로 빠르게 분할  

이제는 단순히 함수 이름이 아니라 **의도에 맞는 선택의 기준**이 생겼다. 
예전 같으면 모든 데이터를 sort 했겠지만, 지금은 “상위 10개만 필요하다면 partial_sort면 충분하지 않을까?”라고 생각하게 된다.


## 3. STL의 시대적 진화 — 기술이 변하면 사고도 바뀐다

문서를 정리하며 특히 인상 깊었던 것은 **STL의 변화가 곧 C++의 진화** 그 자체였다는 점이다.

| 시대 | 주요 버전 | 특징 | 키워드 |
|------|------------|------|--------|
| 98~03 | 초기 STL | 로컬 시스템 중심 | vector, map, sort |
| 11~14 | 멀티코어, 효율화 | move, emplace, thread |
| 17 | 서버·데이터 중심 | parallel, string_view, optional |
| 20 | 스트리밍 시대 | ranges, span, format |
| 23 | 분산·서비스 중심 | expected, print, zip |

<br />
예전에는 단지 문법의 변화로만 느껴졌지만, 이제는 그 변화의 **시대적 흐름**이 보였다.  
STL은 더 이상 “컨테이너 모음”이 아니라, **데이터 스트림과 병렬 처리를 자연스럽게 다루는 프레임워크**가 되었다.


## 4. 느낀 점 — 늦게라도 돌아와서 다행이다

솔직히 말해, 이번 학습은 단순한 복습이 아니었다. **개발자로서의 초심을 되찾는 과정**이었다.  
C++을 처음 배웠던 시절엔 문법이 어렵고 무겁다고 느꼈는데, 지금은 오히려 **그 무게가 주는 안정감과 표현력**이 새삼 고맙다.  

C++ STL은 결코 낡은 기술이 아니다. 그 안에는 여전히 깊이 있는 철학과, 수십 년의 검증된 설계가 담겨 있다.  
오랜 시간 돌아왔지만, 다시 이 구조들을 하나하나 이해하면서 “내가 왜 프로그래밍을 좋아하게 되었는가”를 다시 떠올리게 되었다.


## 마무리

C++ STL은 결국 **자료구조와 알고리즘의 집약체**다. 
그 원리를 이해하지 못하면 효율적인 코드도, 아름다운 설계도 불가능하다.  

이번 학습을 통해 느낀 건, “기본으로 돌아가는 것”이 결국 **가장 빠른 성장의 길**이라는 점이었다.  
그리고 그 기본은 여전히 C++ 안에 살아 있다.


> “STL을 다시 배우는 건, 단순한 문법 공부가 아니라 사고방식의 재정립이다.”

## **전체 문서 보기**  
- [C++ STL 컨테이너 구조와 알고리즘 정리 (ver.2025.10.22)](/assets/docs/C++-STL-컨테이너-구조와-알고리즘-정리.pdf)